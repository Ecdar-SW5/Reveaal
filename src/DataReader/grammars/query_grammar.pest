queries = {SOI ~ queryList? ~ EOI}

queryList = {query ~ ";" ~ queryList | query}

query = {refinement | consistency | reachability | implementation | determinism | specification | getComponent | prune | bisim | logicFormulas}


refinement = {"refinement:" ~ expr ~ "<=" ~ expr}

consistency = {"consistency:" ~ expr}

implementation = {"implementation:" ~ expr}

getComponent = {"get-component:" ~ saveExpr}

prune = {"prune:" ~ saveExpr}

bisim = {"bisim-minim:" ~ saveExpr}

determinism = {"determinism:" ~ expr}

specification = {"specification:" ~ expr}

saveExpr = {  expr  ~ "save-as" ~ variable}

expr = { terms ~ (featureOperator ~ terms)*}

logicFormulas = {possibly | invariantly | eventuallyAlways | potentially}

possibly = {"E<>" ~ boolExpr}

invariantly = {"A[]" ~ boolExpr}

eventuallyAlways = {"E[]" ~ boolExpr}

potentially = {"A<>" ~ boolExpr}

boolExpr = {andExpr}

andExpr = { orExpr ~ "&&" ~ andExpr | orExpr }

orExpr = { compExpr ~ "||" ~ orExpr | compExpr }

compExpr = {subExpr ~ operator ~ compExpr | subExpr}

subExpr = {parenthesizedSubExp |notExpr | term}

notExpr = {"not" ~ boolExpr}

parenthesizedSubExp = { "(" ~ boolExpr ~ ")"}

terms = { term | parenthesizedExp  }

parenthesizedExp = { "(" ~ expr ~ ")"}

term = {atom | var}
atom = {int | "true" | "false" }

var = {variable ~ ":" ~ logicFormulas | variable}
variable = { (variable_name ~ "."?)+ ~ (int | variable_name)?}
variable_name = @{(ASCII_ALPHA ~ (ASCII_ALPHANUMERIC | "_")*) ~ !"-"}

int = @{ "0" | ASCII_NONZERO_DIGIT ~ ASCII_DIGIT* }

operator = {">=" | "<=" | "<" | ">"}

featureOperator = _{ qoutient_op | conjunction_op | composition_op }

qoutient_op = { "//" | "\\\\" }
conjunction_op = { "&&" }
composition_op = { "||" }

WHITESPACE = _{ " " | "\n" | "\r\n" | "\t"}

behavior_specification = { "$" ~ int ~ }                                                                     // Used for specifying behavior for machines i.e. "(M1$1 \\ M2) || M1$2)"
loc = { expr ~ (behavior_specification)? [L" ~ int ~ "]" ~ (featureOperator ~ loc)? }                        // Can take locations of format "M1[L1] && M2[L4]"
clock = { boolExpr | "" }                                                                                    // Is used for inputs like x>0 or y<=3
clocks = { clock ~ "," ~ clocks | clock }                                                                    // Introduces the concept of recursion as done in BNF
reachability = { "reachability:" ~ expr ~ "->" ~ loc ~ "(" ~ clocks ~ ")" ~ "," ~ loc ~ "(" ~ clocks ~ ")" } // This is the format for reachability